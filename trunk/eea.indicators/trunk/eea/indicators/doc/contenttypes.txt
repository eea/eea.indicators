The Indicators Database
=======================

:vim: set ft=doctest:

We have several main content types. The most important are the Specification and their Assessments.

	>>> self.loginAsPortalOwner()
	>>> from Products.CMFCore.utils import getToolByName
	>>> setuptool = getToolByName(portal, 'portal_setup')
	>>> setuptool.setImportContext('profile-eea.dataservice:default')
	>>> log = setuptool.runAllImportSteps()
	>>> setuptool.setImportContext('profile-eea.indicators:default')
	>>> log = setuptool.runAllImportSteps()

    >>> from Products.Five.testbrowser import Browser
    >>> from Products.PloneTestCase import PloneTestCase
    >>> browser = Browser()
    >>> browser.handleErrors = False
    >>> self.portal.error_log._ignored_exceptions = ()
    >>> browser.addHeader('Authorization',
    ...                   'Basic %s:%s' % (PloneTestCase.portal_owner,
    ...                                    PloneTestCase.default_password))
    >>> def types_in_container(container):
    ...     types = [t.__class__.__name__ for t in container.objectValues()]
    ...     return sorted(types)
    >>>

Containments
------------
The Specifications are implicitly addable. It is the duty of the portal manager to 
create a special folder to store them. 

	>>> id = self.portal.invokeFactory('Folder', 'ims')
	>>> ims = portal[id]

Inside this folder we will add Specifications:

	>>> id = ims.invokeFactory("Specification", 'spec1')
	>>> spec = ims[id]

Specifications are containers for several types of objects: 

	>>> id = spec.invokeFactory("PolicyQuestion", 'pq')
	>>> id = spec.invokeFactory("MethodologyReference", "mr")
	>>> id = spec.invokeFactory("RationaleReference", "rr")
	>>> id = spec.invokeFactory("WorkItem", "wi")
	>>> id = spec.invokeFactory("Assessment", 'as')

An Assessment can contain AssessmentParts:

	>>> as = spec['as']
	>>> id = as.invokeFactory("AssessmentPart", 'ap')

An AssessmentPart can contain EEAFigures:

	>>> ap = as['ap']
	>>> id = ap.invokeFactory("EEAFigure", 'ef')

Inside the ims folder, where the Specification was created, we will also create several
other objects that can be referenced from the Specification.

	>>> id = ims.invokeFactory("ExternalDataSpec", 'eds')
	>>> id = ims.invokeFactory("PolicyDocumentReference", 'pdr')


Relationships
-------------
The IMS uses the relatedItems field to store all relationships. We use the eea.relations 
widget and infrastructure to be able to specify which object a relation can contain.

	>>> reltool = portal['portal_relations']

Specifications can point to  PolicyDocumentReferences, ExternalDataSpecs and Data 
(from eea.dataservice).

	>>> id = ims.invokeFactory("Data", 'dt')
	>>> spec.setRelatedItems([ims['dt'], ims['eds'], ims['pdr']])

AssessmentParts point to the answered PolicyQuestion (but the relatedItems field here
is not multiValued):

	>>> ap.setRelatedItems(spec['pq'])

Installing the eea.indicators package will execute a setup step that installs new
objects in the portal_relations tools:

	>>> relations = getToolByName(portal, 'portal_relations')
	>>> ids = set(relations.objectIds())
	>>> our_ids = set(['specification', 'eea-data', 
	...								 'policy-document-reference', 'specification-eea-data', 
	...								 'specification-policy-document-reference'])
	>>> ids.intersection(our_ids) == our_ids
	True


Versioning and utility views
----------------------------

Editing the IMS should be done through a modified Edit form, which aggregates 
all content into a single view, to make editing the tree of objects easier.

	>>> spec = ims[ims.invokeFactory("Specification", 'spec2')]
    >>> spec_url = spec.absolute_url()

Object factories
~~~~~~~~~~~~~~~~
One important feature are the object factories: this is a concept were we
customize the process of creating an object. 

Note: these object factories are not the same as the ones from Plone. 

The following objects are created in the Edit view of Specification through object factories:

    >>> browser.open("%s/object_factory?type_name=RationaleReference" % spec_url)
    >>> browser.open("%s/object_factory?type_name=WorkItem" % spec_url)
    >>> browser.open("%s/object_factory?type_name=MethodologyReference" % spec_url)
    >>> browser.open("%s/object_factory?type_name=PolicyQuestion" % spec_url)
    >>> browser.open("%s/object_factory?type_name=Assessment" % spec_url)
    >>> print types_in_container(spec)
    ['Assessment', 'MethodologyReference', 'PolicyQuestion', 'RationaleReference', 'WorkItem']
    
An newly created Assessment should already have an AssessmentPart created, linked to the already 
created PolicyQuestion.

    >>> ast = spec.objectValues('Assessment')[0]
    >>> ast.objectValues()
    [<AssessmentPart at ...>]
    >>> ap = ast.objectValues('AssessmentPart')[0]
    >>> pq = spec.objectValues('PolicyQuestion')[0]
    >>> ap.getRelatedItems()[0] == pq
    True

Versioning
~~~~~~~~~~

Specifications have versions; a version of a specification is a new revision of the Spec; 
it is a completely restructured specification, with new format for Assessments. This is implemented
with eea.versions
 
Assessments have versions, each year the specifications gets new assessments. 

When creating a new version of a Specification, the new specification is a copy of the old, 
with the following exceptions:

 * none of the assessments are copied
 * the work items are not copied
 * the rest of the contained content items are copied

    >>> v_url = spec.unrestrictedTraverse('@@createVersion')()
    >>> print v_url
    http://nohost/plone/ims/spec2-1
    >>> v_spec = ims[v_url.split('/')[-1]]
    >>> print types_in_container(v_spec)
    ['MethodologyReference', 'PolicyQuestion', 'RationaleReference']

When creating a new version of an Assessment, the new assessment is a copy of the old, 
with the following exceptions:

 * All the EEAFigures contained inside are copy of the ones in the previous assessment 
   but must be linked as new versions of the figures in the older assessment.

    >>> spec = ims['spec2']
    >>> ast = spec.objectValues('Assessment')[0]
    >>> ap = ast.objectValues('AssessmentPart')[0]
    >>> browser.open('%s/object_factory?type_name=EEAFigure' % ap.absolute_url())
    >>> figure_1 = ap.objectValues('EEAFigure')[0]
    >>> print figure_1
    <EEAFigure at ...> 
    >>> v_ast = spec[ast.unrestrictedTraverse('@@createVersion')().split('/')[-1]]
    >>> print v_ast
    <Assessment at ...>
    >>> ap = v_ast.objectValues('AssessmentPart')[0]
    >>> figure_2 = ap.objectValues('EEAFigure')[0]
    >>> versions = figure_1.unrestrictedTraverse('@@getVersions')().values()
    >>> figure_1 in versions
    True
    >>> figure_2 in versions
    True

Adding a new Assessment will already create it as a version of the previous one.

EEAFigures inside an assessment cannot be versioned via the Plone GUI. Only when a user 
create a new Assessment new version of Figures are made and done by code (see above). 

When creating a new Assessment for a Specification, the Assessment should already contain
AssessmentParts created for all the PolicyQuestions - this is already demonstrated above.


Catalog Indexes
---------------

We index the codes of a Specification using the get_codes index. First, let's 
test if it's installed:

    >>> catalog = getToolByName(portal, 'portal_catalog')
    >>> 'get_codes' in catalog.indexes()
    True

There is some cleanup done for codes input in Specification.setCodes():

    >>> spec.setCodes([{}])
    >>> spec.getCodes()
    ()
    >>> spec.setCodes([{'set':'CSI', 'code':'001'}])
    >>> spec.getCodes()
    ({'code': '001', 'set': 'CSI'},)
    >>> spec.setCodes([{'set':'CSI', 'code':''}])
    >>> spec.getCodes()
    ()
    >>> spec.setCodes([{'set':'CSI', 'code':'001'}, {'set':'TERM', 'code':'002'}])
    >>> spec.getCodes()
    ({'code': '001', 'set': 'CSI'}, {'code': '002', 'set': 'TERM'})

Specification.get_codes() will return a structure that can be used to find Specs in 
catalog searches based on either the full code or the Set code:

    >>> spec.get_codes()
    ['CSI', 'CSI001', 'TERM', 'TERM002']


Readiness for publication
-------------------------

We have a system that uses eea.workflow to decide if a Specification is ready to be published.

	>>> spec = ims[ims.invokeFactory("Specification", 'spec3')]

First, we have a portlet that shows the readiness state for a Specification:

    >>> "Total number of fields" in spec.portlet_readiness()
    True

This portlet uses a special view that is registered on objects that 
implement eea.workflow.interfaces.IHasMandatoryWorkflowFields: 

    >>> view = spec.unrestrictedTraverse('@@get_readiness')
    >>> info = view.get_info_for('published')

A specification has 24 fields. From these, 10 are required to be able to transition to 
'published'. The call to get_info_for returns a mapping with the 
keys 'done', 'required', 'publishing', 'optional', 'total', '' 

'done' tells us the percentage of the content that is required for the desired state. Because
no content has been entered in the spec, it is at 0:

    >>> info['done']
    0

'required' is the number of fields that have content filled in and are required for that state

    >>> info['required']
    0 

'publishing' is the number of fields that are required to be filled in for that state.

    >>> info['publishing']
    10

'optional' is the number of fields that are not required for that state and don't have a value.

    >>> info['optional']
    14

This makes the number of field that are optional, but have a value is now 0.

    >>> info['total'] - info['optional'] - info['publishing']
    0

This is the id, locallyAllowedTypes (which is not marked as metadata)

'total' is the grand total number of fields.

    >>> info['total']
    24

Filling up the title, which is one of the required fields, will change the statistics:
Now the spec is at 10% readiness (the 'done' value) and one of the 'required' fields is
filled in.

    >>> spec.setTitle('Some title')
    >>> info = spec.unrestrictedTraverse('@@get_readiness').get_info_for('published')
    >>> info['done']
    10
    >>> info['required']
    1

Let's fill in another field, this time 'codes':

    >>> spec.setCodes([{'set':'CSI', 'code':'001'}, {'set':'TERM', 'code':'002'}])
    >>> view = spec.unrestrictedTraverse('@@get_readiness')
    >>> info = view.get_info_for('published')
    >>> info['done']
    20
    >>> info['required']
    2

The get_readiness view can also tell us if the object is ready for publishing:

    >>> view.is_ready_for('published')
    False

Let's make this spec ready for publishing:

    >>> spec.setDpsir('D')
    >>> spec.setTypology('A')
    >>> spec.setRationale_justification(u'something')
    >>> spec.setPolicy_context_description(u'something')
    >>> spec.setDefinition(u'something')
    >>> spec.setUnits(u'something')
    >>> spec.setMethodology(u'something')

Now we should be at 90%:

    >>> info = spec.unrestrictedTraverse('@@get_readiness').get_info_for('published')
    >>> info['done']
    90
    >>> info['required']
    9

Let's try to finish it:

    >>> spec.setManager_user_id(u'something')
    >>> view = spec.unrestrictedTraverse('@@get_readiness')
    >>> info = view.get_info_for('published')
    >>> info['done']
    100
    >>> info['required']
    10
    >>> view.is_ready_for('published')
    False

It's not yet ready for published because there's an override for get_readiness that adds a
few extra checks: we need to have at least one main policy question and some related items:

	>>> spec.setRelatedItems([ims['dt'], ims['eds'], ims['pdr']])
	>>> id = spec.invokeFactory("PolicyQuestion", 'pq')
    >>> pq = spec.objectValues('PolicyQuestion')[0]
    >>> pq.setIs_key_question(True)
    >>> spec.unrestrictedTraverse('@@get_readiness').is_ready_for('published')
    True


title
codes
dpsir
typology
rationale_justification
policy_context_description
definition
units
methodology
manager_user_id
