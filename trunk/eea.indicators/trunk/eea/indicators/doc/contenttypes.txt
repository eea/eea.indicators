The Indicators Database
=======================
# vim: ft=doctest:
# vim: sw=4 ts=4 et:

We have several main content types. The most important are the Specification and their Assessments.

    >>> import urllib
    >>> from Products.Five.testbrowser import Browser
    >>> from Products.PloneTestCase import PloneTestCase

    >>> self.loginAsPortalOwner()
    >>> from Products.CMFCore.utils import getToolByName
    >>> setuptool = getToolByName(portal, 'portal_setup')
    >>> setuptool.setImportContext('profile-eea.dataservice:default')
    >>> log = setuptool.runAllImportSteps()
    >>> setuptool.setImportContext('profile-eea.indicators:default')
    >>> log = setuptool.runAllImportSteps()

    >>> browser = Browser()
    >>> browser.handleErrors = True
    >>> browser.raiseHttpErrors = False
    >>> self.portal.error_log._ignored_exceptions = ()
    >>> browser.addHeader('Authorization',
    ...                   'Basic %s:%s' % (PloneTestCase.portal_owner,
    ...                                    PloneTestCase.default_password))
    >>> def types_in_container(container):
    ...     types = [t.__class__.__name__ for t in container.objectValues()]
    ...     return sorted(types)
    >>> print browser.headers
    >>> print browser.contents
    >>>

Containments
------------
The Specifications are implicitly addable. It is the duty of the portal manager to 
create a special folder to store them. 

    >>> id = self.portal.invokeFactory('Folder', 'ims')
    >>> ims = portal[id]

Inside this folder we will add Specifications:

    >>> id = ims.invokeFactory("Specification", 'spec1')
    >>> spec = ims[id]

Specifications are containers for several types of objects: 

    >>> id = spec.invokeFactory("PolicyQuestion", 'pq')
    >>> id = spec.invokeFactory("MethodologyReference", "mr")
    >>> id = spec.invokeFactory("RationaleReference", "rr")
    >>> id = spec.invokeFactory("WorkItem", "wi")
    >>> id = spec.invokeFactory("Assessment", 'as')

An Assessment can contain AssessmentParts:

    >>> as = spec['as']
    >>> id = as.invokeFactory("AssessmentPart", 'ap')

An AssessmentPart can contain EEAFigures:

    >>> ap = as['ap']
    >>> id = ap.invokeFactory("EEAFigure", 'ef')

Inside the ims folder, where the Specification was created, we will also create several
other objects that can be referenced from the Specification.

    >>> id = ims.invokeFactory("ExternalDataSpec", 'eds')
    >>> id = ims.invokeFactory("PolicyDocumentReference", 'pdr')


Relationships
-------------
The IMS uses the relatedItems field to store all relationships. We use the eea.relations 
widget and infrastructure to be able to specify which object a relation can contain.

    >>> reltool = portal['portal_relations']

Specifications can point to  PolicyDocumentReferences, ExternalDataSpecs and Data 
(from eea.dataservice).

    >>> id = ims.invokeFactory("Data", 'dt')
    >>> spec.setRelatedItems([ims['dt'], ims['eds'], ims['pdr']])

AssessmentParts point to the answered PolicyQuestion (but the relatedItems field here
is not multiValued):

    >>> ap.setRelatedItems(spec['pq'])

Installing the eea.indicators package will execute a setup step that installs new
objects in the portal_relations tools:

    >>> relations = getToolByName(portal, 'portal_relations')
    >>> ids = set(relations.objectIds())
    >>> our_ids = set(['specification', 'eea-data', 
    ...                              'policy-document-reference', 'specification-eea-data', 
    ...                              'specification-policy-document-reference'])
    >>> ids.intersection(our_ids) == our_ids
    True


Versioning and utility views
----------------------------

Editing the IMS should be done through a modified Edit form, which aggregates 
all content into a single view, to make editing the tree of objects easier.

    >>> spec = ims[ims.invokeFactory("Specification", 'spec2')]
    >>> spec_url = spec.absolute_url()

Object factories
~~~~~~~~~~~~~~~~
One important feature are the object factories: this is a concept were we
customize the process of creating an object. 

Note: these object factories are not the same as the ones from Plone. 

The following objects are created in the Edit view of Specification through object factories:

    >>> browser.open("%s/object_factory?type_name=RationaleReference" % spec_url)
    >>> browser.open("%s/object_factory?type_name=WorkItem" % spec_url)
    >>> browser.open("%s/object_factory?type_name=MethodologyReference" % spec_url)
    >>> browser.open("%s/object_factory?type_name=PolicyQuestion" % spec_url)
    >>> browser.open("%s/object_factory?type_name=Assessment" % spec_url)
    >>> print types_in_container(spec)
    ['Assessment', 'MethodologyReference', 'PolicyQuestion', 'RationaleReference', 'WorkItem']
    
An newly created Assessment should already have an AssessmentPart created, linked to the already 
created PolicyQuestion.

    >>> ast = spec.objectValues('Assessment')[0]
    >>> ast.objectValues()
    [<AssessmentPart at ...>]
    >>> ap = ast.objectValues('AssessmentPart')[0]
    >>> pq = spec.objectValues('PolicyQuestion')[0]
    >>> ap.getRelatedItems()[0] == pq
    True

Versioning
~~~~~~~~~~

Specifications have versions; a version of a specification is a new revision of the Spec; 
it is a completely restructured specification, with new format for Assessments. This is implemented
with eea.versions
 
Assessments have versions, each year the specifications gets new assessments. 

When creating a new version of a Specification, the new specification is a copy of the old, 
with the following exceptions:

 * none of the assessments are copied
 * the work items are not copied
 * the rest of the contained content items are copied

    >>> v_url = spec.unrestrictedTraverse('@@createVersion')()
    >>> print v_url
    http://nohost/plone/ims/spec2-1
    >>> v_spec = ims[v_url.split('/')[-1]]
    >>> print types_in_container(v_spec)
    ['MethodologyReference', 'PolicyQuestion', 'RationaleReference']

When creating a new version of an Assessment, the new assessment is a copy of the old, 
with the following exceptions:

 * All the EEAFigures contained inside are copy of the ones in the previous assessment 
   but must be linked as new versions of the figures in the older assessment.

    >>> spec = ims['spec2']
    >>> ast = spec.objectValues('Assessment')[0]
    >>> ap = ast.objectValues('AssessmentPart')[0]
    >>> browser.open('%s/object_factory?type_name=EEAFigure' % ap.absolute_url())
    >>> figure_1 = ap.objectValues('EEAFigure')[0]
    >>> print figure_1
    <EEAFigure at ...> 
    >>> v_ast = spec[ast.unrestrictedTraverse('@@createVersion')().split('/')[-1]]
    >>> print v_ast
    <Assessment at ...>
    >>> ap = v_ast.objectValues('AssessmentPart')[0]
    >>> figure_2 = ap.objectValues('EEAFigure')[0]
    >>> versions = figure_1.unrestrictedTraverse('@@getVersions')().values()
    >>> figure_1 in versions
    True
    >>> figure_2 in versions
    True

Adding a new Assessment will already create it as a version of the previous one.

EEAFigures inside an assessment cannot be versioned via the Plone GUI. Only when a user 
create a new Assessment new version of Figures are made and done by code (see above). 

When creating a new Assessment for a Specification, the Assessment should already contain
AssessmentParts created for all the PolicyQuestions - this is already demonstrated above.


Catalog Indexes
---------------

We index the codes of a Specification using the get_codes index. First, let's 
test if it's installed:

    >>> catalog = getToolByName(portal, 'portal_catalog')
    >>> 'get_codes' in catalog.indexes()
    True

There is some cleanup done for codes input in Specification.setCodes():

    >>> spec.setCodes([{}])
    >>> spec.getCodes()
    ()
    >>> spec.setCodes([{'set':'CSI', 'code':'001'}])
    >>> spec.getCodes()
    ({'code': '001', 'set': 'CSI'},)
    >>> spec.setCodes([{'set':'CSI', 'code':''}])
    >>> spec.getCodes()
    ()
    >>> spec.setCodes([{'set':'CSI', 'code':'001'}, {'set':'TERM', 'code':'002'}])
    >>> spec.getCodes()
    ({'code': '001', 'set': 'CSI'}, {'code': '002', 'set': 'TERM'})

Specification.get_codes() will return a structure that can be used to find Specs in 
catalog searches based on either the full code or the Set code:

    >>> spec.get_codes()
    ['CSI', 'CSI001', 'TERM', 'TERM002']


Readiness for publication
-------------------------

We have a system that uses eea.workflow to decide if a Specification is ready to be published.

    >>> spec = ims[ims.invokeFactory("Specification", 'spec3')]

First, we have a portlet that shows the readiness state for a Specification:

    >>> "Total number of fields" in spec.portlet_readiness()
    True

This portlet uses a special view that is registered on objects that 
implement eea.workflow.interfaces.IHasMandatoryWorkflowFields: 

    >>> view = spec.unrestrictedTraverse('@@get_readiness')
    >>> info = view.get_info_for('published')

A specification has 23 fields. From these, 11 are required to be able to transition to 
'published'. The call to get_info_for() returns a mapping with the 
keys 'done', 'required', 'publishing', 'optional', 'total', '' 

'done' tells us the percentage of the content that is required for the desired state. 
By default the title is filled in, so we will be at 9%:

    >>> print str(info['done']) + '%'
    9%

'required' is the number of fields that have content filled in and are required for that state

    >>> info['required']
    1 

'publishing' is the number of fields that are required to be filled in for that state.

    >>> info['publishing']
    11

'optional' is the number of fields that are not required for that state and don't have a value.

    >>> info['optional']
    12

'total' is the grand total number of fields.

    >>> info['total']
    23

Let's fill in another field, this time 'codes':

    >>> spec.setCodes([{'set':'CSI', 'code':'001'}, {'set':'TERM', 'code':'002'}])
    >>> view = spec.unrestrictedTraverse('@@get_readiness')
    >>> info = view.get_info_for('published')
    >>> print str(info['done']) + '%'
    18%
    >>> info['required']
    2

The get_readiness view can also tell us if the object is ready for publishing:

    >>> view.is_ready_for('published')
    False

Let's move on making this spec ready for publishing:

    >>> spec.setDpsir('D')
    >>> spec.setTypology('A')
    >>> spec.setRationale_justification(u'something')
    >>> spec.setPolicy_context_description(u'something')
    >>> spec.setDefinition(u'something')
    >>> spec.setUnits(u'something')
    >>> spec.setMethodology(u'something')
    >>> spec.setManager_user_id(u'something')

Now we should be at 90%:

    >>> info = spec.unrestrictedTraverse('@@get_readiness').get_info_for('published')
    >>> print str(info['done']) + '%'
    90%
    >>> info['required']
    10

Let's try to finish it:

    >>> spec.setRelatedItems([ims['dt'], ims['eds'], ims['pdr']])
    >>> view = spec.unrestrictedTraverse('@@get_readiness')
    >>> info = view.get_info_for('published')
    >>> print str(info['done']) + '%'
    100%
    >>> info['required']
    11
    >>> view.is_ready_for('published')
    False

It's not yet ready for published because there's an override to the default provided eea.workflow
get_readiness that adds a few extra checks: we need to have at least one 
main policy question and some related items:

    >>> id = spec.invokeFactory("PolicyQuestion", 'pq')
    >>> pq = spec.objectValues('PolicyQuestion')[0]
    >>> pq.setIs_key_question(True)
    >>> spec.unrestrictedTraverse('@@get_readiness').is_ready_for('published')
    True

We'll reindex this object because we need it later for some entries in the catalog.

    >>> catalog = getToolByName(portal, 'portal_catalog')
    >>> catalog.reindexObject(spec)


Simple field editing and schemata editing
-----------------------------------------

In the new aggregated edit view we use two types of editing dialog boxes:

 * one where we edit just one field
 * another one where we edit a full schemata

Single field dialog edit
~~~~~~~~~~~~~~~~~~~~~~~~

Single field edit forms are based on a modified base_edit.cpt template that presents a 
single field.

    >>> baseurl = spec.absolute_url()
    >>> browser.open(baseurl + '/simple_edit?fieldset=default&specific_field=title')
    >>> print browser.contents  #doctest: +NORMALIZE_WHITESPACE
    <... <form ... id="specification-base-edit"...

Inside we will have the field:

    >>> title = browser.getControl(name='title')

The submit button is created by javascript, through the jQuery UI framework. 
Submiting the form, if the form is properly validated, will return a small Javascript
fragment that closes the dialog and reloads the region to which that field belongs:

    >>> req = {'specific_field':'title', 'fieldset':'default', 'title':'Some title', 
    ...        'form.submitted':'1', 'form_submit':'Save'}
    >>> data = urllib.urlencode(req)
    >>> browser.open(baseurl + '/simple_edit', data=data)
    >>> print browser.contents  #doctest: +NORMALIZE_WHITESPACE
    <script>...closer(...'title'...)...</script>

Schemata dialog edit
~~~~~~~~~~~~~~~~~~~~

Several content types can be edited from the aggregated edit view in a full popup edit form.
They are: WorkItems, MethodologyReferences, RationaleReferences and PolicyQuestions

	>>> pq = spec.objectValues('PolicyQuestion')[0]
	>>> url = pq.absolute_url()
	>>> browser.open(url + '/schemata_edit?fieldset=default')
	>>> browser.getControl(name="title").value = 'First question'
	>>> browser.getForm(name="edit_form").submit()
	>>> print browser.contents		#doctest: +NORMALIZE_WHITESPACE
	<script>...close_dialog...</script>

If the form that was submited fails validation, it is redisplayed. Because we have edited
the title, the PolicyQuestion's id was changed, so let's get it again.

	>>> url = pq.absolute_url()
	>>> browser.open(url + '/schemata_edit?fieldset=default')
	>>> browser.getControl(name="title").value = ''
	>>> browser.getForm(name="edit_form").submit()
	>>> print browser.contents		#doctest: +NORMALIZE_WHITESPACE
	<...form...>

Specification.codes validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Specification.codes are unique for a Specification across the IMS, unless the 
objects are versions of each other.

We already have a specification with codes [{'set':'CSI', 'code':'001'}, {'set':'TERM', 'code':'002'}]
Let's create another and try to duplicate the code:

    >>> spec = ims[ims.invokeFactory("Specification", 'spec4')]
    >>> baseurl = spec.absolute_url()
    >>> req = (
    ...     ('codes.set:records','CSI'),
    ...     ('codes.code:records','001'),
    ...     ('codes.orderindex_:records','1'),
    ...     ('codes.set:records','TERM'),
    ...     ('codes.code:records','002'),
    ...     ('codes.orderindex_:records','2'),
    ...     ('codes.set:records','APE'),
    ...     ('codes.code:records',''),
    ...     ('codes.orderindex_:records','template_row_marker'),
    ... 
    ...     ('fieldset','Classification'),
    ...     ('form.submitted','1'), 
    ...     ('form_submit','Save'),
    ...     ('specific_field','codes'),
    ... )
    >>> data = urllib.urlencode(req)
    >>> browser.open(baseurl + '/simple_edit', data=data)

This edit will fail validation:

    >>> 'closer(' in browser.contents
    False
    >>> print browser.contents  #doctest: +NORMALIZE_WHITESPACE
    <...Validation failed, there is already another Specification with code CSI001...

Setting another code will result in a successful edit:

    >>> req = (
    ...     ('codes.set:records','CSI'),
    ...     ('codes.code:records','123'),
    ...     ('codes.orderindex_:records','1'),
    ...     ('codes.set:records','TERM'),
    ...     ('codes.code:records','321'),
    ...     ('codes.orderindex_:records','2'),
    ...     ('codes.set:records','APE'),
    ...     ('codes.code:records',''),
    ...     ('codes.orderindex_:records','template_row_marker'),
    ... 
    ...     ('fieldset','Classification'),
    ...     ('form.submitted','1'), 
    ...     ('form_submit','Save'),
    ...     ('specific_field','codes'),
    ... )
    >>> data = urllib.urlencode(req)
    >>> browser.open(baseurl + '/simple_edit', data=data)
    >>> print browser.contents  #doctest: +NORMALIZE_WHITESPACE
    <script>...closer(...'codes'...)...</script>


Work Items classification
-------------------------

Work items are shown on the aggregated edit splitted in 3 categories:
 * those that need to be finished in the far future (over a year from now)
 * those that need to be finished in a year
 * unclassified, without a deadline

We have a special method, Specification.get_work() which returns a mapping
with its work items classified:

	>>> _ = spec.invokeFactory("WorkItem", 'w1')
	>>> _ = spec.invokeFactory("WorkItem", 'w2')
	>>> _ = spec.invokeFactory("WorkItem", 'w3')
	>>> _ = spec.invokeFactory("WorkItem", 'w4')
	>>> import datetime
	>>> now = datetime.datetime.now()
	>>> one_year = datetime.timedelta(days=365)
	>>> one_month = datetime.timedelta(days=30)
	>>> spec['w1'].setDue_date(str(now + one_month))
	>>> spec['w2'].setDue_date(str(now + one_year))
	>>> spec['w3'].setDue_date(str(now + one_month + one_year))
	>>> works = spec.get_work()
	>>> print len(works['short']), len(works['long']), len(works['incomplete'])
	1 2 1

Work that is due in the past appears, for the moment, in the 'short term' category.
This may be change in the future.

	>>> _ = spec.invokeFactory("WorkItem", 'w5')
	>>> spec['w5'].setDue_date('2009-05-20')
	>>> works = spec.get_work()
	>>> print len(works['short']), len(works['long']), len(works['incomplete'])
	2 2 1


